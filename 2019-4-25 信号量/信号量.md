# 信号量 #

信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。为了完成这个过程，需要创建一个信号量VI，然后将Acquire Semaphore VI以及Release Semaphore VI分别放置在每个关键代码段的首末端。确认这些信号量VI引用的是初始创建的信号量。

##描述

以一个停车场的运作为例。简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入外面的一辆进去，如果又离开两辆，则又可以放入两辆，如此往复。
在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。

##分类

整型信号量（integer semaphore)：信号量是整数

记录型信号量（record semaphore)：每个信号量s除一个整数值s.value（计数）外，还有一个进程等待队列s.L，其中是阻塞在该信号量的各个进程的标识

二进制信号量(binary semaphore)：只允许信号量取0或1值

每个信号量至少须记录两个信息：信号量的值和等待该信号量的进程队列。它的类型定义如下：（用类PASCAL语言表述）

semaphore = record

value: integer;

queue: ^PCB;

end;

其中PCB是进程控制块，是操作系统为每个进程建立的数据结构。

s.value>=0时，s.queue为空；

s.value<0时，s.value的绝对值为s.queue中等待进程的个数；


##特性

抽象的来讲，信号量的特性如下：信号量是一个非负整数（车位数），所有通过它的线程/进程（车辆）都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。当一个线程调用Wait操作时，它要么得到资源然后将信号量减一，要么一直等下去（指放入阻塞队列），直到信号量大于等于一时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为释放了由信号量守护的资源。

##操作方式

对信号量有4种操作(#include<semaphore.h>)：

1. 初始化（initialize），也叫做建立（create） int sem_init(sem_t *sem, int pshared, unsigned int value);

2. 等信号（wait），也可叫做挂起（suspend）int sem_wait(sem_t *sem);

3. 给信号（signal）或发信号（post） int sem_post（sem_t *sem）;

4. 清理（destroy） int sem_destory(sem_t *sem);



##IPC对象的概念

ICP指的是进程要访问的对象，多个进程都访问某一个特定的IPC对象，类型为key_t，在<sys/types.h>中定义为一个长整型。

函数ftok可以使用两个参数生成一个键值，函数原型如下：

    #include <sys/ipc.h>
    key_t ftok( const char *path, int id );


程序清单  create_sem.c 使用semget函数创建一个信号量

    #include <sys/types.h>
    #include <sys/ipc.h>
    #include <sys/sem.h>
    #include <stdio.h>
    #include <stdlib.h>
    int main( void )
    {
    int sem_id;
    int nsems = 1;
    int flags = 0666;
    struct sembuf buf;
    sem_id = semget(IPC_PRIVATE, nsems, flags); /*创建一个新的信号量集*/
    if ( sem_id < 0 ){
    perror( "semget ") ;
    exit (1 );
    }
    /*输出相应的信号量集标识符*/
    printf ( "successfully created a semaphore : %d\n", sem_id );
    buf.sem_num = 0; /*定义一个信号量操作*/
    buf.sem_op = 1; /*执行释放资源操作*/
    buf.sem_flg = IPC_NOWAIT; /*定义semop函数的行为*/
    if ( (semop( sem_id, &buf, nsems) ) < 0) { /*执行操作*/
    perror ( "semop");
    exit (1 );
    }
    system ( "ipcs -s " ); /*查看系统IPC状态*/
    exit ( 0 );
    }



另外的一篇介绍：

## linux进程间通信-信号量（semaphore） ##

一 为什么要使用信号量

为了**防止出现因多个程序同时访问一个共享资源而引发的一系列问题**，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问 代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它， 也就是说信号量是用来调协进程对共享资源的访问的。其中共享内存的使用就要用到信号量。

二 信号量的工作原理

由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：

P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行

V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.
 
举个例子，就是 **两个进程共享信号量sv**，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为 当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。

三 Linux的信号量机制
Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件sys/sem.h中。

四 信号号相关的两个结构体
内核为每个信号量集合设置了一个semid_ds结构

    struct semid_ds {
    struct ipc_permsem_perm ;
    structsem* sem_base ; //信号数组指针
    ushort sem_nsem ; //此集中信号个数
    time_t sem_otime ; //最后一次semop时间
    time_t sem_ctime ; //最后一次创建时间
    } ;

每个信号量由一个无名结构表示，它至少包含下列成员： （这个是什么意思？？）
    struct {
    ushort_t semval ; //信号量的值
    short sempid ; //最后一个调用semop的进程ID
    ushort semncnt ; //等待该信号量值大于当前值的进程数（一有进程释放资源 就被唤醒）
    ushort semzcnt ; //等待该信号量值等于0的进程数
    } ;

三 信号量的使用

1、创建信号量

semget函数创建一个信号量集或访问一个已存在的信号量集。

    #include <sys/sem.h>
    int semget (key_t key, int nsem, int oflag) ;

返回值是一个称为信号量标识符的整数，semop和semctl函数将使用它。
参数nsem指定集合中的信号量数。（若用于访问一个已存在的集合，那就可以把该参数指定为0）
参数oflag可以是SEM_R(read)和SEM_A(alter)常值的组合。（打开时用到），也可以是IPC_CREAT或IPC_EXCL ;
 
2、打开信号量

使用semget打开一个信号量集后，对其中一个或多个信号量的操作就使用semop(op--operate)函数来执行。

    #include <sys/sem.h>
    int semop (int semid, struct sembuf * opsptr, size_t nops) ;

参数opsptr是一个指针，它指向一个信号量操作数组，信号量操作由sembuf结构表示：


    struct sembuf{
    short sem_num; // 除非使用一组信号量，否则它为0
    short sem_op; // 信号量在一次操作中需要改变的数据，通常是两个数，
	// 一个是-1，即P（等待）操作，一个是+1，即V（发送信号）操作
	short sem_flg; // 通常为SEM_UNDO,使操作系统跟踪信号，并在进程没有释放该信号量而终止时，
	// 操作系统释放信号量
	};

◆参数nops规定opsptr数组中元素个数。

sem_op值：

（1）若sem_op为正，这对应于进程释放占用的资源数。sem_op值加到信号量的值上。（V操作）

（2）若sem_op为负,这表示要获取该信号量控制的资源数。信号量值减去sem_op的绝对值。（P操作）

（3）若sem_op为0,这表示调用进程希望等待到该信号量值变成0

◆如果信号量值小于sem_op的绝对值（资源不能满足要求），则：

（1）若指定了IPC_NOWAIT，则semop()出错返回EAGAIN。

（2）若未指定IPC_NOWAIT，则信号量的semncnt值加1（因为调用进程将进 入休眠状态），然后调用进程被挂起直至：①此信号量变成大于或等于sem_op的绝对值；②从系统中删除了此信号量，返回EIDRM；③进程捕捉到一个信 号，并从信号处理程序返回，返回EINTR。（与消息队列的阻塞处理方式 很相似）

 3、信号量是操作

semctl函数对一个信号量执行各种控制操作。

	#include <sys/sem.h>
	int semctl (int semid, int semnum, int cmd, /*可选参数*/ ) ;

第四个参数是可选的，取决于第三个参数cmd。

参数semnum指定信号集中的哪个信号（操作对象）

    参数cmd指定以下10种命令中的一种,在semid指定的信号量集合上执行此命令。
    IPC_STAT   读取一个信号量集的数据结构semid_ds，并将其存储在semun中的buf参数中。
    IPC_SET 设置信号量集的数据结构semid_ds中的元素ipc_perm，其值取自semun中的buf参数。
    IPC_RMID  将信号量集从内存中删除。
    GETALL  用于读取信号量集中的所有信号量的值。
    GETNCNT  返回正在等待资源的进程数目。
    GETPID  返回最后一个执行semop操作的进程的PID。
    GETVAL  返回信号量集中的一个单个的信号量的值。
    GETZCNT   返回这在等待完全空闲的资源的进程数目。
    SETALL   设置信号量集中的所有的信号量的值。
    SETVAL  设置信号量集中的一个单独的信号量的值。

四 信号量值的初始化

semget并不初始化各个信号量的值，这个初始化必须通过以SETVAL命令(设置集合中的一个值)或SETALL命令(设置集合中的所有值) 调用semctl来完成。

SystemV信号量的设计中，创建一个信号量集并将它初始化需两次函数调用是一个致命的缺陷。一个不完备的解决方案是：在调用semget时指定IPC_CREAT | IPC_EXCL标志，这样只有一个进程（首先调用semget的那个进程）创建所需信号量，该进程随后初始化该信号量。

详见：https://www.cnblogs.com/fangshenghui/p/4039946.html

https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F/9807501?fr=aladdin